#!/usr/bin/env python
#cd ~/Desktop/SU_Aur_backup/channels/bg_sub/flat/im_distort/align/OE/QU/rotated_QU/aligned_QU/flux_scaling/PA_diskmajoraxis
'''
This file generates the radial PI distribution along PA=15 and 195 (major axis)
The radial PI distribution is generated by plotting the normalized flux as
a function of radius (from boundary of mask to r~80 AU).
The goal is to acquire the power index of the radial distribution.
This is done by fitting a power function (resembling a straight line)
in a log log plot.
There is some problem regarding what conv sigma of image to use because it yields different power indices. For consistency, use sigma=2.
Export new_rscale and image_ave.txt and use them for plotting and
getting the power index in excel.

'''
from pylab import *
import pyfits
from scipy.ndimage.interpolation import rotate
import numpy as np
from matplotlib.patches import Ellipse
cmap=cm.jet
cmap.set_bad('black',1)

#z=pyfits.open('obj_PI_fs_conv_sigma008.fits')
#z=pyfits.open('obj_PI_fs_conv_sig01.fits')
z=pyfits.open('obj_PI_a_fs_conv_sig02.fits')
obj_PI_fs_conv=z[0].data-1.1e-7
z.close()

#define image center
scale=9.53e-3*140
xcenter=271
ycenter=318

#crop image; 401x401
#obj_PI_fs_conv_cropped=obj_PI_fs_conv[ycenter-200:ycenter+201,xcenter-200:xcenter+201]
obj_PI_fs_conv_cropped=obj_PI_fs_conv[ycenter-270:ycenter+271,xcenter-270:xcenter+271]

figure(0)
clf()
extent=array([-200,200,-200,200])*scale 
imshow(log10(obj_PI_fs_conv_cropped),interpolation='nearest',origin='lower',cmap=cm.jet,extent=extent,vmin=-7.4,vmax=-5)
plot([0,0], [0, 200*scale], color='w', linestyle='--', linewidth=1)
xlabel('AU')
ylabel('AU')
title('original image (PA=0)')

##scale the axes in AU; make array with 400 elements and subtract 200: [-200,-199,..199,200]*AU conversion factor
rscale=(arange(401)-200)*scale

#angle of image rotation along the major axis
angle=15
rotated_image=rotate(obj_PI_fs_conv_cropped,angle)
dim=rotated_image.shape[0]
midpoint   =dim/2

extent_PI=array([-midpoint,midpoint,-midpoint,midpoint])*scale
figure(1)
clf()
imshow(log10(rotated_image),extent=extent_PI,vmin=-7.4,vmax=-5,cmap=cmap)
plot([0,0], [0, midpoint*scale], color='w', linestyle='--', linewidth=1)
xlabel('AU')
ylabel('AU')
axis([-150,150,-150,150])
colorbar()
title('P.A.= %d deg.' % angle)

figure(2)
clf()
#get the average of of flux along the vertical (PA=15) +-2 pixels (5 columns) to increase SNR
image1=rotated_image[midpoint:,midpoint+1]*scale
image2=rotated_image[midpoint:,midpoint-1]*scale
image3=rotated_image[midpoint:,midpoint+2]*scale
image4=rotated_image[midpoint:,midpoint-2]*scale
image5=rotated_image[midpoint:,midpoint]*scale
image_ave=(image1+image2+image3+image4+image5)/5

#new_rscale=log((arange(rotated_image.shape[0])-midpoint)*scale)
new_rscale=(arange(rotated_image.shape[0])-midpoint)*scale
#get only the positive values of flux; midpoint>=0
new_rscale=new_rscale[midpoint:]

p1, p2 = -1, -2.8
constant= 0.0498
#fit a power law with exponent p=-1
power_law_m1= 1e-4 * new_rscale ** p1
power_law_m2= constant * new_rscale ** p2
loglog(new_rscale,image_ave,'k-')

#log log plot of power law 
label1, label2 = 'p= %.1f' %p1, str(constant)+'r ** %.1f' % p2
#loglog(new_rscale,power_law_m1,'g--',label=label1)
loglog(new_rscale,power_law_m2,'b--',label=label2)
#plot([0,0], [5e-8, 3e-5], color='r', linestyle='--', linewidth=1) #this is a vertical line along the origin

#input the last pixel = boundary of disk
end_pix_disk= 60
label3= 'mask boundary (r=20 AU); disk boundary r=%.1f AU' % ((end_pix_disk+1)*scale)

#mark the point marking the boundary of the mask at r=15, before of which the flux is unreliable, and also the last pixel used in fitting (flux>0)
loglog(15*scale,image_ave[15], 'ro',label=label3)
loglog(end_pix_disk*scale,image_ave[end_pix_disk], 'ro') #for PA=15
axis([0,1000,5e-8,3e-5]) #AU scale
ylabel('log (n_PI / n*)')
xlabel('log(r) (AU)')
title('Power law index: %.1f for PA=%d' % (p2,angle))
legend(loc='upper right', shadow=True)

#Takami+13 used 0."3 arcsec in diameter mask
#0."3 arcsec/*0.00948arcsec/pix = 31.65 pixels
hmask,wmask= 30*scale,30*scale #radius = 15 pix = 20 AU
m=Ellipse(xy=(0,0),height=hmask,width=wmask)
figure(0).add_subplot(111).add_artist(m)
n=Ellipse(xy=(0,0),height=hmask,width=wmask)
figure(1).add_subplot(111).add_artist(n)
m.set_color('k')
n.set_color('k')
show()
'''
np.savetxt('image_ave_PA15.txt',image_ave)
np.savetxt('new_rscale_PA15.txt',new_rscale)

import powerlaw
data = array([1.7, 3.2 ...]) # data can be list or numpy array
results = powerlaw.Fit(data)
print results.power_law.alpha
print results.power_law.xmin
R, p = results.distribution_compare('power_law', 'lognormal')
'''
